---
title: Docker
description: |
    A hybrid-source application designed to deploy nested-virtual machines that are containerized applications.
sidebar:
    label: Docker
    order: 100
unsplash: 1605745341112-85968b19335b
img: https://images.unsplash.com/photo-1605745341112-85968b19335b?fit=crop&w=1400&h=700&q=75
---

import {
	Aside,
	Steps,
	Card,
	CardGrid,
	Code,
	FileTree,
} from '@astrojs/starlight/components';


## Tools

<Aside type="danger" title="Docker Tool Inbound">

This is just a short place holder for a docker tool that I am making!

</Aside>

## Information

In one sentence, we can describe docker as a hybrid-source application designed to deploy nested-virtual machines that are containerized applications.
Docker is a powerful tool that can help you develop, deploy, and manage your applications.
The Docker build process lets you package your application and all its dependencies into a single image.
This image can then be run on any machine that has Docker installed, regardless of the underlying operating system.
Think of the image as a virtual cd or iso, it has everything needed to run your software wrapped into a single fancy file.
Finally the image/container makes it easy to deploy your application to any environment, whether it's a local development machine, a cloud server, or a production environment.
It's easy to get started with Docker, and you can be up and running in just a few minutes to about a hour if you are a bit noobie.
Remember that containers are lightweight, isolated environments that make it easy to deploy your applications.
They're also portable, so you can run them on any machine that has Docker installed.
So docker takes your source code, wraps it all into an image, then runs the image in a virtual machine aka container.
Also, in this documentation, we will include more additional tips, such as security and optimization, for your docker adventure.

---

## Cheatsheet

This is a quick cheetsheet for Docker, everyone comes back to these sheet for when they run into future problems or forget a certain command.
It is not important to understand this cheetsheet until you have a couple sessions of docker delopyment under your belt, so if you are a newbie, do not freak out!

-   Basic CLI (Command-line interface)
    -   Container Management Commands
        -   `docker create $image [-command]` - Create a Docker Container based upon the image String; -command for additional flags.
        -   `docker run $image [-command]` - Combines the command `create` and `start`.
        -   `docker start $cont` - Start the specific docker container (defined via cont String).
        -   `docker stop $cont` - Shutdown the specific docker container (defined via cont String).
        -   `docker kill $cont` - Kill the specific docker container (defined via cont String).
        -   `docker restart $cont` - Restart the specific docker container (defined via cont String).
        -   `docker pause $cont` - Pause the specific docker container (defined via cont String).
        -   `docker rm $cont` - Remove the specific docker container (defined via cont String).
    -   Inspecting Containers
        -   `docker ps` - List running docker containers.
        -   `docker ps -a` - List all docker containers, including docker containers that are paused / off.
        -   `docker logs $cont` - Display the specific docker container output (defined via cont String)
        -   `docker top $cont [-ps]` - Display the processes running inside the specific docker container (defined via cont String).
        -   `docker diff $cont` - Show the differences, within the modified files, between the specific container and the source image (defined via cont String).
        -   `docker inspect $cont` - Show information about the specific docker container (defined via cont String).
            -   Output of the data will default to `json`.
    -   Interacting with Containers
        -   `docker attach $cont` - Attach to the specific docker container and see the _stdin, stdout, stderr_ (defined via cont String)
        -   `docker cp $cont:$path $hostpath` - Copy files from the docker container.
        -   `docker cp $hostpath $cont:$path` - Copy files into the docker container.
        -   `docker export $cont` - Export the data of the specific docker container.
            -   Output of the data will default to a `tar` archive.
        -   `docker exec $cont $command` - Runs the $command inside of the specific docker container (defined via cont String).
        -   `docker wait $cont` - Waits until the specific docker container terminates and returns an exit code.
        -   `docker commit $cont $image` - Commits a new docker image via a snapshot of the specific docker container.
    -   Network
        -   `docker network create $netname` - Create a network with the variable $netname.
    -   Docker Compose
        -   `docker compose start` - Start a YAML configuration for a docker container.
        -   `docker compose stop` - Stop the most recent composed docker container.
        -   `docker compose pause` - Pause the most recent composed docker container.
        -   `docker compose unpause` - Unpause the most rencent composed docker container.
        -   `docker compose ps` - List the current docker containers
        -   `docker compose up -f $compose.yml [$command]` - Start and run a YAML configuration for a docker container.
        -   `docker compose down` - Down a composed docker container.
    -   Docker Swarm
        -   `docker swarm init` - The docker container will become a manager node within the initialized container.
            -   Upon the initialization instance, the container will provide a token for other worker/manager nodes to join.
        -   `docker swarm join --token $token $ip` - Docker container will join the swarm as a worker; token string should be obtained by init and the `$ip` should be IP Address and port.
            -   `$ip` will be given as `$$ipaddress:$$port` , where the substring `$$ipaddress` is the IPv4address or IPv6address and the substring `$$port` is the open port on that `$$ipaddress`.
    -   Docker Prune / Clean up
        -   `docker system prune` - The docker system will clean up any dead objects, such as containers, networks, ect..
            -   `docker system prune -a` - Incase you need to do a deep clean within the docker node.

---

## DockerFile

A Dockerfile is a crucial component in building Docker images, serving as a simple script that specifies the base image and a set of instructions to assemble the final image.
Acting as an isolated operating system for specific applications, a Dockerfile ensures all necessary libraries and dependencies are pre-installed and pre-built.
This document aims to provide a comprehensive guide for all Docker needs, catering to both new users and professionals, by covering essential concepts and advanced techniques for effective Docker usage.

<Aside type="tip" title="Understanding the Dockerfile">
	The Dockerfile is a simple document that assembles the Docker image using a
	specific base and a set of commands. The concept is that the Docker image
	acts as an isolated operating system for the specific application, with all
	necessary libraries pre-installed and pre-built.
</Aside>

### FROM

The `FROM` instruction in a Dockerfile specifies the base image for the Docker image being built.
There are four generic ways to use `FROM`:

| Method                        | Description                                                                                                                                                                                                                                                                                                     |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. `FROM {image}`             | The `{image}` represents the base image title or reference, such as `ubuntu` or `alpine`.                                                                                                                                                                                                                       |
| 2. `FROM {image}:{tag}`       | The `{tag}` specifies a particular version of the image, which can be useful for ensuring consistency. For example, `node:16` or `node:16-bullseye`.                                                                                                                                                            |
| 3. `FROM {image}@{digest}`    | The `{digest}` is the `sha-256` hash used to verify the integrity of the image. It ensures that the image has not been altered and is exactly as expected.                                                                                                                                                      |
| 4. `FROM {repository}#{hash}` | The `{repository}#{hash}` allows specifying a base image directly from a GitHub repository using a specific commit hash. This method is particularly useful when the base image is hosted in a repository and the exact state of the code is needed. For example, `FROM github.com/kbve/repo#abcdef1234567890`. |

Using these methods, the `FROM` instruction provides flexibility and precision in defining the base image, ensuring that the Docker image is built upon a reliable and verified foundation.

### MAINTAINER

<Aside type="caution" title="Caution: Deprecated Instruction">
	The **MAINTAINER** instruction has been deprecated. For current best
	practices, refer to the **LABEL** section.
</Aside>

The `MAINTAINER` instruction in a Dockerfile specifies the author or maintainer of the Docker image.
Although deprecated in favor of using labels, it is still useful to know for legacy Dockerfiles.
The `MAINTAINER` instruction provides metadata about the person or organization responsible for maintaining the image.

| Option                              | Description                                                                                                                  |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `MAINTAINER {name}`                 | Specifies the name of the maintainer. For example, `MAINTAINER h0ly Byte`.                                                   |
| `MAINTAINER {name} <email>`         | Provides both the name and email of the maintainer. For example, `MAINTAINER h0ly Byte <no.reply@kbve.com>`.                 |
| `LABEL maintainer="{name} <email>"` | The recommended way to specify the maintainer using labels. For example, `LABEL maintainer="h0ly Byte <no.reply@kbve.com>"`. |

This table illustrates the different ways to specify the maintainer information, emphasizing the shift towards using labels for better metadata management.

### RUN

The `RUN` instruction in a Dockerfile is used to execute commands within the container during the image build process.
It allows for the installation of software packages, modification of files, and other tasks required to set up the environment for the application.

| Method                                   | Description                                                                                                                                                      |
| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `RUN {command}`                          | Executes a command in a new layer on top of the current image and commits the results. For example, `RUN apt-get update && apt-get install -y nginx`.            |
| `RUN ["executable", "param1", "param2"]` | Uses the exec form to run the command. This is typically preferred for commands that include arguments. For example, `RUN ["apt-get", "install", "-y", "curl"]`. |

The table above illustrates the different ways to use the `RUN` instruction to execute commands during the build process, either using the shell form or the exec form, depending on the requirements.

<Aside type="tip" title="RUN vs. CMD">
	The **RUN** and **CMD** instructions in a Dockerfile serve different
	purposes. **RUN** executes commands during the build process to set up the
	image, such as installing software or setting environment variables,
	creating a new image layer each time it's used. In contrast, **CMD**
	specifies the default command to run when the container starts, determining
	the container's behavior at runtime. Use **RUN** for build-time
	configurations and **CMD** for runtime configurations to ensure a clear and
	effective Dockerfile.
</Aside>

### CMD

The `CMD` instruction in a Dockerfile specifies the default command to run when a container is started.
Unlike `RUN`, which is used during the build process, `CMD` is executed when the container runs.
If multiple `CMD` instructions are specified, only the last one takes effect.

| Method                                 | Description                                                                                                                                       |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `CMD ["executable","param1","param2"]` | Specifies the command to run in exec form. For example, `CMD ["nginx", "-g", "daemon off;"]`. This form is preferred for commands with arguments. |
| `CMD ["param1","param2"]`              | Provides default parameters for the `ENTRYPOINT` instruction. For example, `CMD ["-d"]` when combined with `ENTRYPOINT ["nginx"]`.                |
| `CMD command param1 param2`            | Specifies the command to run in shell form. For example, `CMD echo "Hello, World!"`. This form runs in a shell (`/bin/sh -c`).                    |

The reference CMD table above explains the different ways to use the `CMD` instruction, either by specifying the command in exec form, providing default parameters for an `ENTRYPOINT`, or using shell form to run commands.

Sure! Here are the detailed sections with markdown tables for each of the requested Dockerfile instructions:

### LABEL

The `LABEL` instruction in a Dockerfile is used to add metadata to the image.
Labels can provide information such as the maintainer's name, version, description, and other key-value pairs.

| Method                          | Description                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------ |
| `LABEL key=value`               | Adds a label with a key-value pair. For example, `LABEL version="1.0"`.                    |
| `LABEL key1=value1 key2=value2` | Adds multiple labels at once. For example, `LABEL maintainer="John Doe" version="1.0"`.    |
| `LABEL key="value with spaces"` | Adds a label with a value that includes spaces. For example, `LABEL description="My App"`. |

### ENV

The `ENV` instruction in a Dockerfile sets environment variables, which can be used by the running container.
Environment variables set using `ENV` persist throughout the lifetime of the container.

| Method                        | Description                                                                                           |
| ----------------------------- | ----------------------------------------------------------------------------------------------------- |
| `ENV key=value`               | Sets an environment variable. For example, `ENV PATH=/usr/local/nginx/bin:$PATH`.                     |
| `ENV key value`               | Sets an environment variable using key and value as separate arguments. For example, `ENV PORT 8080`. |
| `ENV key1=value1 key2=value2` | Sets multiple environment variables at once. For example, `ENV LANG=C.UTF-8 LC_ALL=C.UTF-8`.          |

<Aside type="tip" title="COPY vs. ADD">
	While both **COPY** and **ADD** instructions in a Dockerfile are used to
	copy files from the host to the container, there are key differences.
	**COPY** simply copies local files and directories, ensuring a
	straightforward and predictable behavior. **ADD**, on the other hand, can
	also handle remote URLs and automatically extract compressed files (e.g.,
	tar archives). For most use cases, **COPY** is preferred for its clarity and
	simplicity, reserving `ADD` for scenarios where its additional features are
	necessary.
</Aside>

### ADD

The `ADD` instruction in a Dockerfile copies files, directories, or remote URLs from the source to the destination in the container.
Unlike `COPY`, `ADD` can also handle remote URLs and extract tar archives.

| Method                              | Description                                                                                                                 |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `ADD src dest`                      | Copies files or directories from `src` to `dest`. For example, `ADD myapp.tar.gz /app`.                                     |
| `ADD ["src", "dest"]`               | Copies files or directories from `src` to `dest` using the exec form. For example, `ADD ["app.conf", "/etc/app.conf"]`.     |
| `ADD http://example.com/file /file` | Downloads a file from a URL and copies it to the container. For example, `ADD http://example.com/file.tar.gz /file.tar.gz`. |

### COPY

The `COPY` instruction in a Dockerfile copies files and directories from the source on the host to the destination path in the container.
Unlike `ADD`, `COPY` only supports copying local files and directories.

| Method                 | Description                                                                                                              |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `COPY src dest`        | Copies files or directories from `src` to `dest`. For example, `COPY myapp /app`.                                        |
| `COPY ["src", "dest"]` | Copies files or directories from `src` to `dest` using the exec form. For example, `COPY ["app.conf", "/etc/app.conf"]`. |
| `COPY src/ dest/`      | Copies contents of a directory from `src` to `dest`. For example, `COPY src/ /app/`.                                     |

### ENTRYPOINT

The `ENTRYPOINT` instruction in a Dockerfile specifies the command that will always be executed when the container starts.
It allows configuring a container to run as an executable.

| Method                                          | Description                                                                                                                                              |
| ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ENTRYPOINT ["executable", "param1", "param2"]` | Specifies the command to run in exec form. For example, `ENTRYPOINT ["nginx", "-g", "daemon off;"]`. This form is preferred for commands with arguments. |
| `ENTRYPOINT command param1 param2`              | Specifies the command to run in shell form. For example, `ENTRYPOINT /bin/sh -c "echo Hello"`. This form runs in a shell (`/bin/sh -c`).                 |

### VOLUME

The `VOLUME` instruction in a Dockerfile creates a mount point with a specified path and marks it as holding externally mounted volumes from native host or other containers.
It is used to persist data generated by and used by the Docker container.

| Method                      | Description                                                                                  |
| --------------------------- | -------------------------------------------------------------------------------------------- |
| `VOLUME ["/data"]`          | Creates a volume at the specified path. For example, `VOLUME ["/data"]`.                     |
| `VOLUME /data`              | Creates a volume at the specified path using the string form. For example, `VOLUME /data`.   |
| `VOLUME ["path1", "path2"]` | Creates multiple volumes at the specified paths. For example, `VOLUME ["/data", "/config"]`. |

### USER

The `USER` instruction in a Dockerfile sets the user name or UID (and optionally the group name or GID) to use when running the image and for any `RUN`, `CMD`, and `ENTRYPOINT` instructions that follow.

| Method            | Description                                                                                    |
| ----------------- | ---------------------------------------------------------------------------------------------- |
| `USER user`       | Sets the user to run the container as. For example, `USER nginx`.                              |
| `USER user:group` | Sets the user and group to run the container as. For example, `USER nginx:nginx`.              |
| `USER uid`        | Sets the user by UID to run the container as. For example, `USER 1001`.                        |
| `USER uid:gid`    | Sets the user and group by UID and GID to run the container as. For example, `USER 1001:1001`. |

### WORKDIR

The `WORKDIR` instruction in a Dockerfile sets the working directory for any `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions that follow.
If the directory does not exist, it will be created.

| Method                     | Description                                                                          |
| -------------------------- | ------------------------------------------------------------------------------------ |
| `WORKDIR /path/to/workdir` | Sets the working directory for subsequent instructions. For example, `WORKDIR /app`. |
| `WORKDIR /path/to/workdir` | Creates the directory if it does not exist. For example, `WORKDIR /usr/src/app`.     |

### ARG

The `ARG` instruction in a Dockerfile defines a variable that users can pass at build-time to the builder with the `docker build` command.
These variables can be used in the Dockerfile to customize the build process.

| Method                          | Description                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------ |
| `ARG name`                      | Defines a build-time variable. For example, `ARG VERSION`.                                 |
| `ARG name=default`              | Defines a build-time variable with a default value. For example, `ARG VERSION=latest`.     |
| `ARG name1=value1 name2=value2` | Defines multiple build-time variables at once. For example, `ARG VERSION=1.0 BASE=alpine`. |

### ONBUILD

The `ONBUILD` instruction in a Dockerfile adds a trigger instruction to the image that will be executed when the image is used as a base for another build.
It is useful for images that are intended to be used as a base for other images.

| Method                 | Description                                                                                                     |
| ---------------------- | --------------------------------------------------------------------------------------------------------------- |
| `ONBUILD INSTRUCTION`  | Adds a trigger instruction to be executed when the image is used as a base. For example, `ONBUILD COPY . /app`. |
| `ONBUILD RUN command`  | Adds a trigger instruction to run a command. For example, `ONBUILD RUN echo "Building child image"`.            |
| `ONBUILD ADD src dest` | Adds a trigger instruction to copy files. For example, `ONBUILD ADD . /src`.                                    |

### STOPSIGNAL

The `STOPSIGNAL` instruction in a Dockerfile sets the system call signal that is used to stop the container or application.
The default setting sends `SIGTERM` and waits for 10 seconds to allow for a graceful shutdown before sending `SIGKILL`.

| Method              | Description                                                                                       |
| ------------------- | ------------------------------------------------------------------------------------------------- |
| `STOPSIGNAL signal` | Sets the system call signal to stop the container. For example, `STOPSIGNAL SIGINT`.              |
| `STOPSIGNAL signal` | The default setting is `SIGTERM`, with a 10-second wait for a graceful shutdown before `SIGKILL`. |

### HEALTHCHECK

The `HEALTHCHECK` instruction in a Dockerfile provides a way to determine the health status of a container, informing the swarm or manager about the general status of the running application.
The two primary statuses are `healthy` and `unhealthy`.

| Method                                           | Description                                                                                                                                    |
| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- | --- | -------- |
| `HEALTHCHECK [options] CMD command`              | Defines a command to test the container's health. For example, `HEALTHCHECK CMD curl -f http://localhost/                                      |     | exit 1`. |
| `HEALTHCHECK NONE`                               | Disables any health checks inherited from the base image.                                                                                      |
| `HEALTHCHECK --interval=30s --timeout=10s \ CMD` | Specifies options such as interval, timeout, and retries. For example, `HEALTHCHECK --interval=30s --timeout=10s CMD curl -f http://localhost/ |     | exit 1`. |

### SHELL

The `SHELL` instruction allows changing the default shell used for the `RUN` instruction.

| Method                          | Description                                                                                                   |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `SHELL ["executable", "param"]` | Changes the default shell for subsequent `RUN` instructions. For example, `SHELL ["powershell", "-Command"]`. |

### EXPOSE

The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
This is a form of documentation and does not actually publish the port.

| Method                 | Description                                                                    |
| ---------------------- | ------------------------------------------------------------------------------ |
| `EXPOSE port`          | Specifies a port to be listened to by the container. For example, `EXPOSE 80`. |
| `EXPOSE port/protocol` | Specifies a port and protocol (TCP/UDP). For example, `EXPOSE 80/tcp`.         |

---

## GPU

### Windows

GPU pass-through on Windows is still in the experimental stage, but here are some quick ways to get started with the basics.
This guide assumes you have WSL (Windows Subsystem for Linux) installed.
If you need assistance with WSL, refer to [WSL Help](https://kbve.com/application/wsl/).

#### Nvidia

- Install the latest CUDA driver libraries from the official Nvidia website. Visit [Nvidia CUDA](https://developer.nvidia.com/cuda-downloads) for downloads and installation instructions.
- Ensure you have installed the latest core libraries as per the provided instructions.

---

## Setup

Docker is the future of application development because of how fast, easy and portable the software is.
In this section of the document, we will focus on setting up the application on various operating systems, including linux, windows and mac.
With Docker, you can build, deploy, and manage your applications in a fraction of the time it would take with traditional methods.
If you're not using Docker, you're missing out.
So what are you waiting for homie!?
Let us begin the setup quest for Docker today!

This section breaks down the various areas of installing `docker`.
To install Docker, simply visit the Docker website and download the installer for your operating system.

### Linux

The operating sysetm that we perfer is `Ubuntu` and here is a quick and brief tutorial:

-   Ubuntu Installation Guide
    -   Core Pre-Installation
        -   `lsb_release -a` - Unix command to see the version of Ubuntu that we are running.
        -   According to Docker (2022), these are the 64-bit versions of Ubuntu that they support.
            -   `Ubuntu Jammy 22.04 (LTS)`
            -   `Ubuntu Impish 21.10`
            -   `Ubuntu Focal 20.04 (LTS)`
            -   `Ubuntu Bionic 18.04 (LTS)`
        -   Hint: We like to make sure everything is updated and upgraded before we start. So run `sudo apt-get update` and then `sudo apt-get upgrade`.
        -   Now there are libraries that you will need before installing docker.
    -   Post Installation
        -   Adding Docker Compose through `sudo apt-get install docker-compose-plugin`, you may need to update before installing.
        -   Verifying the installation through `docker compose version` and if there are any issues, visit our support.

### Windows

Before we being our journey on setting up `Docker` onto Windows, you will have to make sure that WSL is installed and ready.
Furthermore, you may need to enable the Hyper-V through your bios.

The best way to setup `Docker` is by installing the engine through `Choco` because it will help keep the engine up to date.

---

## BuildX

Buildx is an advanced Docker CLI plugin designed to enhance the container building experience by providing extended capabilities powered by BuildKit.
Leveraging multi-node and multi-platform builds, Buildx facilitates the creation of containers optimized for diverse architectures, such as ARM and x86.
The plugin supports cache export and import features, improving build efficiency and speeding up subsequent builds.
Additionally, Buildx integrates seamlessly with Docker, allowing users to manage build environments with ease.
The flexibility and power of Buildx make it an essential tool for developers seeking to streamline their containerization workflows and deploy applications across various environments.

<Aside type="tip" title="Tip: Maximize Build Efficiency with Caching">
	Take advantage of Buildx's cache export and import features to significantly
	speed up your builds. By reusing previously built layers, cache can minimize
	build times and reduce redundant processing. Ensure to set up cache
	effectively to optimize development workflows.
</Aside>

<Steps>

0. **Prerequisites**:

    Make sure Docker is installed on your system.
    If you need to install Docker, follow this [Docker installation guide](https://kbve.com/application/docker/#setup).

1. **Verify Docker Installation**:

    First, check if Docker is installed by running the following command in your terminal:

    ```shell
    docker --version
    ```

    You should see output similar to:

    ```
    Docker version 20.10.7, build f0df350
    ```

2. **Check for Buildx in the Apt List**:

    Before installing Buildx, let's check if it is available in the apt package list. Run the following command:

    ```shell
    apt-cache search docker-buildx
    ```

    If Buildx is available, you should see an output similar to:

    ```
    docker-buildx - Docker CLI plugin for extended build capabilities with BuildKit
    ```

3. **Install Buildx (if available in apt)**:

    If Buildx is available in the apt list, you can install it using:

    ```shell
    sudo apt-get install docker-buildx
    ```

    Verify the installation by running:

    ```shell
    docker buildx version
    ```

    You should see output indicating the version of Buildx installed.

    An example of this output would be like this:

    ```
    github.com/docker/buildx 0.11.2 0.11.2-0ubuntu1^22.04.2
    ```

4. **Add Buildx (if not available in apt)**:

    <Aside>This is only if Step 3 was not an option.</Aside>

    If Buildx is not available in the apt package list, you can add it manually. Follow these steps:

    1. **Download the Buildx Binary**:

        Download the latest Buildx release from GitHub:

        ```sh
        mkdir -p ~/.docker/cli-plugins/
        curl -Lo ~/.docker/cli-plugins/docker-buildx https://github.com/docker/buildx/releases/latest/download/buildx-v0.10.0.linux-amd64
        ```

    2. **Make the Binary Executable**:

        Make the downloaded binary executable:

        ```sh
        chmod +x ~/.docker/cli-plugins/docker-buildx
        ```

    3. **Verify the Installation**:

        Check the Buildx version to ensure it was installed correctly:

        ```sh
        docker buildx version
        ```

        You should see output indicating the version of Buildx installed.

5. **Create and Use a New Builder Instance**:

    Create a new builder instance and switch to it:

    ```sh
    docker buildx create --name mybuilder --use
    ```

    You can verify that the new builder instance is being used by running:

    ```sh
    docker buildx inspect --bootstrap
    ```

6. **Build and Push Multi-Platform Images**:

    With Buildx, you can now build and push multi-platform images. For example:

    ```sh
    docker buildx build --platform linux/amd64,linux/arm64 -t username/repository:tag . --push
    ```

    Congratulations! You have successfully set up Docker Buildx on your system.

</Steps>

---

## WatchTower

WatchTower is a powerful utility designed to automatically update running Docker containers whenever new images are pushed to a repository.
Ensuring that applications are always running the latest version, WatchTower reduces manual intervention and minimizes downtime.
By continuously monitoring specified Docker containers, WatchTower detects updates, gracefully stops the container, pulls the latest image, and restarts the container with the new version.
Maintaining a smooth and efficient deployment pipeline, WatchTower is especially beneficial in environments where applications frequently update.

In addition to its core functionality, WatchTower can send notifications about the status of container updates.
Notifications can be sent to various channels such as email, Slack, or other messaging services, keeping teams informed about the update process.
This feature is particularly useful for maintaining transparency and ensuring that stakeholders are aware of the changes happening within the containerized environment.

To enable WatchTower notifications, set the appropriate environmental variables in the command line. For example:

```shell
docker run -d \
  --name watchtower \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -e WATCHTOWER_NOTIFICATIONS=email \
  -e WATCHTOWER_NOTIFICATION_EMAIL_FROM=fromaddress@gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_TO=toaddress@gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER=smtp.gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT=587 \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER=fromaddress@gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD=app_password \
  -e WATCHTOWER_NOTIFICATION_EMAIL_DELAY=2 \
  containrrr/watchtower
```

This command configures WatchTower to send email notifications regarding the status of container updates.
Adjust the variables to suit the desired notification method and settings.
By utilizing WatchTower and its notification features, administrators can ensure that their Docker environments remain up-to-date and secure with minimal effort.

---
