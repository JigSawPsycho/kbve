// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JediEnvelope {
    #[prost(int32, tag = "1")]
    pub version: i32,
    #[prost(enumeration = "MessageKind", tag = "2")]
    pub kind: i32,
    #[prost(enumeration = "PayloadFormat", tag = "3")]
    pub format: i32,
    #[prost(bytes = "vec", tag = "4")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlagEnvelope {
    #[prost(int32, tag = "1")]
    pub flag: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlexEnvelope {
    #[prost(enumeration = "MessageKind", tag = "1")]
    pub kind: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawEnvelope {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JediMessage {
    #[prost(oneof = "jedi_message::Envelope", tags = "1, 2, 3, 4")]
    pub envelope: ::core::option::Option<jedi_message::Envelope>,
}
/// Nested message and enum types in `JediMessage`.
pub mod jedi_message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Envelope {
        #[prost(message, tag = "1")]
        Hybrid(super::JediEnvelope),
        #[prost(message, tag = "2")]
        Flex(super::FlexEnvelope),
        #[prost(message, tag = "3")]
        Raw(super::RawEnvelope),
        #[prost(message, tag = "4")]
        Flag(super::FlagEnvelope),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayloadFormat {
    PayloadUnknown = 0,
    Json = 1,
    Flex = 2,
    Protobuf = 3,
    Flatbuffer = 4,
}
impl PayloadFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PayloadUnknown => "PAYLOAD_UNKNOWN",
            Self::Json => "JSON",
            Self::Flex => "FLEX",
            Self::Protobuf => "PROTOBUF",
            Self::Flatbuffer => "FLATBUFFER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYLOAD_UNKNOWN" => Some(Self::PayloadUnknown),
            "JSON" => Some(Self::Json),
            "FLEX" => Some(Self::Flex),
            "PROTOBUF" => Some(Self::Protobuf),
            "FLATBUFFER" => Some(Self::Flatbuffer),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageKind {
    Unknown = 0,
    KeyUpdate = 1,
    Action = 2,
    Message = 4,
    Debug = 8,
    Error = 16,
    Info = 32,
    Auth = 64,
    Heartbeat = 256,
    ConfigUpdate = 512,
}
impl MessageKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::KeyUpdate => "KEY_UPDATE",
            Self::Action => "ACTION",
            Self::Message => "MESSAGE",
            Self::Debug => "DEBUG",
            Self::Error => "ERROR",
            Self::Info => "INFO",
            Self::Auth => "AUTH",
            Self::Heartbeat => "HEARTBEAT",
            Self::ConfigUpdate => "CONFIG_UPDATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "KEY_UPDATE" => Some(Self::KeyUpdate),
            "ACTION" => Some(Self::Action),
            "MESSAGE" => Some(Self::Message),
            "DEBUG" => Some(Self::Debug),
            "ERROR" => Some(Self::Error),
            "INFO" => Some(Self::Info),
            "AUTH" => Some(Self::Auth),
            "HEARTBEAT" => Some(Self::Heartbeat),
            "CONFIG_UPDATE" => Some(Self::ConfigUpdate),
            _ => None,
        }
    }
}
